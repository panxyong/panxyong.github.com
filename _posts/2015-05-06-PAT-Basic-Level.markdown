---
layout: post
title: "PAT Basic Level Practice(1001-1040)"
description: "PAT乙级考试练习题"
categories:
- PAT

tags:
- acm

---

*PAT让我想起了大学时ACM比赛，一直比较菜。如今已脱离行业两三年，偶然遇到PAT，似乎老天在安排什么，笑，吃的盐比当年多了，过的桥也比当年多了，再来做这些练习是不是会得心应手呢？又或是，脑量不足为时已晚！不管怎样，奔着自己AC代码的高兴，奔着企业的绿色通道，干了!*

[PAT Basic Level原题][0]，[Github备份AC代码][1]。刷完40个题，整体简单且代码量小，15分题都很水，20、25分题有坑点，坑点大多在基本的输入输出整型长度上，想清楚多留意就能AC，许多查询题用hash一下子就能解决，以下是做题纪录与小结。
	
	1003    比较难想到，后参考别人提示才AC
	1005    忘记判断n<=100，弄的key[n]哈希数组越界（25‘）
	1010    容易忽略0多项式(25’)
	1033    容易忽略坏键字符串为空的情形（20‘）
	1034    注意要用long long才能AC(20‘)
	1040    递推，比较难想到，有参考别人提示才AC（25‘）
	
	同为哈希的：1005、1033、1038、1039
	
	  
**1001.害死人不偿命的(3n+1)猜想 (15)**
> 
> *解答：偶数则减半，奇数则3n+1再减半，累加步数，变成1止.*
> 


**1002.写出这个数 (20)**
> 
> *解答：把n的每一位相加得到sum，再根据sum的每一位，输出对应数字拼音.*
>


**1003. 我要通过！(20)**
>
>*解答: 根据xPATx正确，aPbTc在b=A,c=a的情况下也正确.而aPbTc正确，则aPbATca正确，便有aPbAATcaa也正确...也就是aPbTc每次b后扩展一个A则c后扩展一个a都正确，即有aPbA...ATca...a也正确（前后省略个数相同），aPbA...ATca...a ＝ aPAA...ATaa...a，以上可概括为：*
>
>>1. *字符串中只有P、A、T*
>>
>>2. *P在前T在后,P、T仅出现一次*
>>
>>3. *P前的A个数＊PT间A的个数＝T后面A的个数；PT间A的个数至少有1个*
>>
>


**1004. 成绩排名 (20)**
>
>**解答**：qsort排序即可。注意qsort中compare函数：
>
>>int compare(const void *a, const void *b)
>>
>>return *a - *b; // 升序 
>>
>>return *b - *a; // 降序
>>
>>也就是return值大于0则a在b之后
>>
>>如果a,b是double，则要return (*a > *b) ? 1 : -1;
>>

**1005. 继续(3n+1)猜想 (25)**
>
>*解答： 哈希法，用key[n]=1先设每个输入的n是关键数，然后对每个n做猜想验证处理，遇到的中间数都标记为非关键数key[n]=0.最后输出key[n]=1的数n.*
>
>

**1006. 换个格式输出整数 (15)**
> 
> **解答**: 得到n的百、十、个位然后依照条件输出即可，十分简单
> 

**1007. 素数对猜想 (20)**
> 
> *解答: n是否为素数的判定*
>
>> 1. 打一素数表p[]，i = 1; p[i] <= sqrt(n); i++; n%p=0则不为素数。
>>
>> 2. 不打表，效率略低：p = 3; p <= sqrt(n); p += 2; 做n%p
>>  

**1008. 数组元素循环右移问题 (20)**

> *解答: 很简单，另外开一个数组存放移动后的数据。*
>
>>如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？刚开始有被这句话误导过，想复杂了，不过貌似到真有一个移动次数更少更节省空间的办法，暂时不管了


**1009. 说反话 (20)**

> *解答:用gets()接受一整行，从后往前扫描，碰到空格意味着跳过了一个单词，输出，直到扫描完整个字符串。*
>
>> 也可以用scanf()单个单词的接收到char *str[];然后从后往前输出。


**1010. 一元多项式求导 (25)**
>
> *解答: 简单的求导，容易忽略多项式为0,0的情形。*
>

**1011. A+B和C (15)**
>
>*解答：变量用long long 解决，scanf("%lld",&a)*
>

**1012. 数字分类 (20)**
>
>*解答：*

**1013.**
>
>*解答：*


**1014.**
>
>*解答：*

**1015.**
>
>*解答：*

**1016.**
>
>*解答：*

**1017.**
>
>*解答：*

**1018.**
>
>*解答：*

**1019.**
>
>*解答：*

**1020.**
>
>*解答：*

**1021.**
>
>*解答：*

**1022.**
>
>*解答：*

**1023.**
>
>*解答：*

**1024.**
>
>*解答：*

**1025.**
>
>*解答：*

**1026.**
>
>*解答：*

**1027.**
>
>*解答：*

**1028.**
>
>*解答：*

**1029.**
>
>*解答：*

**1030.**
>
>*解答：*

**1031.**
>
>*解答：*

**1032.**
>
>*解答：*

**1033.**
>
>*解答：用数组来记录每个键的状态，输出前判断按键是否坏即可*
>>*坑点: 有可能没有坏键，则用scanf()接收输入，空行会出现问题，改用gets()*


**1034.**
>
>*解答：根据a1/b1 a2/b2 求出 a/b；在把a/b化为最简分数 k c/d 输出*
>>*注意坑点：long long才能运算通过*

**1035. 插入与归并(25)**
>
>*解答：分别实现插入排序、归并排序，每排一趟序就对比一次，就能知道所给序列所用的排序方法了*
>
>>*这种方法比较笨，有没有更好的方法判断一个中间序列所用的排序方法呢？*
>>

**1036. 跟奥巴马一起编程(15)**
>
>*解答：输出呗*

**1037. 在霍格沃茨找零钱（20）**
>
>*解答：很简单，模拟时分秒化成秒的方法，Galleon\*17\*29 + Sickle\*29 + Knut;*

**1038. 统计同成绩学生(20)**
>
>*解答：也简单，开一个hash数组纪录每个分数的人数，hash[75]表示得75分的人数，便能很快输出人数*

**1039. 到底买不买（20）**
>
>*解答：很简单，开一个hash数组纪录每个珠子的个数，在减去所需，为负数则不能买，负多少表示差多少*

**1040. 有几个PAT（25）**
>
>*解答：可以用暴力法，三重循环会超时，但按积分点可拿不少分。*
>
>*换个思路，str中PAT的个数 ＝ 第一个P后AT的个数 ＋ 第一个P后PAT的个数；
>P后AT的个数 ＝ A后T的个数 ＋ A后AT的个数；*
>
>*从后往前扫描str,碰到T则t++,碰到A则at = at + t,碰到P则pat = pat + at.*



[0]:http://www.patest.cn/contests/pat-b-practise
[1]:https://github.com/lovelife/PAT/tree/master/Basic%20Level%20Practice
